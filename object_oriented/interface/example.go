package _interface

import (
	"fmt"
	"github.com/pulingao/golang_re-learning/tools"
)

func T_0() {
	s := `
************************************************************************************************************************
在Go语言中接口（interface）是一种类型，一种抽象的类型。

关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。
	不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。

interface是一组method的集合，是 duck-type programming 的一种体现。
	接口做的事情就像是定义一个协议（规则），只要一台机器有洗衣服和甩干的功能，我就称它为洗衣机。
	不关心属性（数据），只关心行为（方法）。

	duck-type programming：鸭子类型
		在程序设计中是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由“当前方法和属性的集合”决定
		“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”
		在鸭子类型中，关注点在于对象的行为，能做什么；而不是关注对象所属的类型
************************************************************************************************************************
`
	fmt.Println(s)
}

// *********************************************************************************************************************
//
//	  _____             __   _____       _
//	 / ____|           / /  / ____|     | |
//	| |  __  ___      / /  | |  __  ___ | | __ _ _ __   __ _
//	| | |_ |/ _ \    / /   | | |_ |/ _ \| |/ _` | '_ \ / _` |
//	| |__| | (_) |  / /    | |__| | (_) | | (_| | | | | (_| |
//	 \_____|\___/  /_/      \_____|\___/|_|\__,_|_| |_|\__, |
//	                                                    __/ |
//	                                                   |___/
//
// *********************************************************************************************************************
type Mover interface {
	move(string, string)
}
type Sayer interface {
	say()
}

type Animal interface {
	Sayer
	Mover
}

type Dog struct {
	name string
}

func (d Dog) move(a, b string) {
	fmt.Printf("%v 从「%v」移动到了「%v」\n", d, a, b)
}

func (d *Dog) say() {
	fmt.Printf("%v 说：我是%T \n", d, d)
}

type Cat struct {
	name string
}

func (c Cat) move(a, b string) {
	fmt.Printf("%v 从「%v」移动到了「%v」\n", c, a, b)
}

func (c Cat) say() {
	fmt.Printf("%v 说：我是%T \n", c, c)
}

/**
 * 值接收者和指针接收者实现接口的区别
 * @see
 * @param
 */
func T_1() {
	var x Mover
	var y Sayer

	// 值接收者和指针同时存在的情况，且一个类型可以实现多个接口，如Dog实现了Mover和Sayer
	var dog = &Dog{name: "旺财"}
	x = dog
	y = dog
	y.say()
	x.move("北京", "上海")

	tools.NewLine()

	// 全部是值接收者
	var ani Animal // 接口嵌套，也相当于实现了这个接口
	var cat = Cat{name: "大器"}
	ani = cat
	ani.say()
	ani.move("上海", "成都")

	tools.NewLine()

	var cat2 = &Cat{name: "晚成"}
	x = cat2
	y = cat2
	y.say()
	x.move("成都", "阆中")

	s := `
========================================================================================================================
结论：
	如果实现中
		1.值接收者和指针接收者都存在，调用时，只能使用取地址的方式（如：&Dog{name: "旺财"}）
		2.只存在值接收者，调用时，则直接赋值和取地址都可以，内部会转换
		3.只存在值接收者，调用时，则只能使用取地址的方式
再总结：
	接口的实现中，只要出现了指针类型的接收者，调用时只能使用取地址的方式，否则，两种都可以
	极端的总结：都使用取地址的方式来调用实现

`
	fmt.Println(s)
}
