package panic_recover

import (
	"fmt"
	"github.com/pulingao/golang_re-learning/tools"
	"math/rand"
	"time"
)

func T_0() {
	s := `
************************************************************************************************************************
panic
	1、内置函数
    2、假如函数F中书写了panic语句，会终止其后要执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照defer的逆序执行
    3、返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的defer函数列表，按照defer的逆序执行
    4、直到goroutine整个退出，并报告错误

recover
	1、内置函数
    2、用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为
    3、一般的调用建议
        a). 在defer函数中，通过recover来终止一个goroutine的panicking过程，从而恢复正常代码的执行
        b). 可以获取通过panic传递的error

注意
	1.利用recover处理panic指令，defer 必须放在 panic 之前定义，另外 recover 只有在 defer 调用的函数中才有效。否则当panic时，recover无法捕获到panic，无法防止panic扩散。
    2.recover 处理异常后，逻辑并不会恢复到 panic 那个点去，函数跑到 defer 之后的那个点。
    3.多个 defer 会形成 defer 栈，后定义的 defer 语句会被最先调用。
************************************************************************************************************************
`
	fmt.Println(s)
}

// *********************************************************************************************************************
//     _____             __   _____       _
//    / ____|           / /  / ____|     | |
//   | |  __  ___      / /  | |  __  ___ | | __ _ _ __   __ _
//   | | |_ |/ _ \    / /   | | |_ |/ _ \| |/ _` | '_ \ / _` |
//   | |__| | (_) |  / /    | |__| | (_) | | (_| | | | | (_| |
//    \_____|\___/  /_/      \_____|\___/|_|\__,_|_| |_|\__, |
//                                                       __/ |
//                                                      |___/
// *********************************************************************************************************************

/**
 * 延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获。
 * @see
 * @param
 */
func T_1() {
	defer func() {
		if err := recover(); err != nil {
			tools.Error("捕获到错误，错误信息：%v", err)
		}
		//输出
		//2023/03/18 14:53:05 [ERRO]  捕获到错误，错误信息：defer的第二个错误
		// 结合方法说明，这里捕获到了错误，但是捕获的是按照逆序调用的抛出错误的 最后一个defer
	}()

	// 逆序调用第二个defer，也是抛出错误的最后一个defer
	defer func() {
		panic("defer的第二个错误")
	}()

	// 逆序调用第一个defer
	defer func() {
		panic("defer panic")
	}()

	panic("test panic")
}

/**
 * 捕获函数 recover 只有在 defer调用的函数内 直接调用 才会终止错误，否则总是返回 nil。任何未捕获的错误都会沿调用堆栈向外传递。
 * @see			注意是直接调用，看下面代码中有效的写法
 * @param
 */
func except() {
	fmt.Println(recover())
}
func T_2() {
	defer except() // 有效
	//defer func() {
	//	//tools.Error("%v", recover()) // 有效
	//	//fmt.Println(recover()) // 有效
	//}()

	defer recover()              // 无效！
	defer fmt.Println(recover()) // 无效！
	defer func() {
		func() {
			println("defer inner")
			recover() // 无效！
		}()
	}()

	panic("出现错误了，我来抛出")

	//输出
	//defer inner
	//<nil>
	//出现错误了，我来抛出

	// 解释
	// 按照逆序执行，结合方法说明，最终只有逆序的最后一个是在defer调用的函数中直接调用的，因此才能正确输出
}

// *********************************************************************************************************************
//     _____             __   _____       _
//    / ____|           / /  / ____|     | |
//   | |  __  ___      / /  | |  __  ___ | | __ _ _ __   __ _
//   | | |_ |/ _ \    / /   | | |_ |/ _ \| |/ _` | '_ \ / _` |
//   | |__| | (_) |  / /    | |__| | (_) | | (_| | | | | (_| |
//    \_____|\___/  /_/      \_____|\___/|_|\__,_|_| |_|\__, |
//                                                       __/ |
//                                                      |___/
// *********************************************************************************************************************

func PanicSimulation(x, y int) {
	var z int
	func() {
		defer func() {
			if err := recover(); err != nil {
				tools.Error("捕获到异常：%v", err)
				z = 0
			}
		}()

		// 模拟一下抛出异常
		if y >= 50 {
			panic(fmt.Sprintf("手动模拟抛出，y的值：%v，太大了", y))
		}
		z = x / y
		return
	}()
	tools.Success("最终结果：%v / %v = %v", x, y, z)
}

/**
 * 如果在一段函数中需要完整的执行下去，避免panic的中断，可以在匿名函数中使用recover将可能出现的异常捕获并处理
 * @see
 * @param
 */
func T_3() {
	PanicSimulation(100, 0)
}

// *********************************************************************************************************************
//     _____             __   _____       _
//    / ____|           / /  / ____|     | |
//   | |  __  ___      / /  | |  __  ___ | | __ _ _ __   __ _
//   | | |_ |/ _ \    / /   | | |_ |/ _ \| |/ _` | '_ \ / _` |
//   | |__| | (_) |  / /    | |__| | (_) | | (_| | | | | (_| |
//    \_____|\___/  /_/      \_____|\___/|_|\__,_|_| |_|\__, |
//                                                       __/ |
//                                                      |___/
// *********************************************************************************************************************

func Try(fun func(), handler func(any)) {
	defer func() {
		if e := recover(); e != nil {
			handler(e)
		}
	}()

	// 执行传入的代码块方法
	fun()
}

/**
 * 实现简单的 Try Catch 的效果
 * @see
 * @param
 */
func T_4() {
	t1 := time.Now()
	tools.Info("当前时间：%v", tools.MySysTimeFormat(t1))
	Try(func() {
		x := 100
		// 随机数
		rand.Seed(time.Now().Unix())
		y := rand.Intn(20)
		z := x / y
		tools.Success("函数正常输出结果：%v / %v = %v", x, y, z)
	}, func(a any) {
		tools.Error("捕获到错误：%v，后续的继续执行", a)
	})

	tools.Info("当前时间：%v，执行时长：%v", tools.MySysTime(), time.Since(t1))
}
