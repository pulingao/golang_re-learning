package _defer

import (
	"fmt"
	"github.com/pulingao/golang_re-learning/tools"
	"sync"
	"time"
)

func T_0() {
	s := `
************************************************************************************************************************
有关defer的使用，参考：
	1.https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8defer.html
	2.https://zhuanlan.zhihu.com/p/56557423
	3.https://go.dev/doc/effective_go#defer //官方说明

defer用途
	1. 关闭文件句柄
    2. 锁资源释放
    3. 数据库连接释放

defer的底层原理
	1.每次defer语句执行的时候，会把函数“压栈”，函数参数会被拷贝下来；
		当外层函数（非代码块，如一个for循环）退出时，defer函数按照定义的逆序执行；
		如果defer执行的函数为nil, 那么会在最终调用函数的产生panic.
	
	2.defer语句并不会马上执行，而是会进入一个栈，函数return前，会按先进后出的顺序执行。
		也就是说最先被定义的defer语句最后执行。
		先进后出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面先执行，那后面函数的依赖就没有了。
	
	3.在defer函数定义时，对外部变量的引用是有两种方式的，分别是作为函数参数和作为闭包引用。
		作为函数参数，则在defer定义时就把值传递给defer，并被cache起来；
		作为闭包引用的话，则会在defer函数真正调用时根据整个上下文确定当前的值。
	
	4.defer后面的语句在执行的时候，函数调用的参数会被保存起来，也就是复制了一份。
		真正执行的时候，实际上用到的是这个复制的变量，因此如果此变量是一个“值”，那么就和定义的时候是一致的。
		如果此变量是一个“引用”，那么就可能和定义的时候不一致。
************************************************************************************************************************
`
	fmt.Println(s)
}

// *********************************************************************************************************************
//     _____             __   _____       _
//    / ____|           / /  / ____|     | |
//   | |  __  ___      / /  | |  __  ___ | | __ _ _ __   __ _
//   | | |_ |/ _ \    / /   | | |_ |/ _ \| |/ _` | '_ \ / _` |
//   | |__| | (_) |  / /    | |__| | (_) | | (_| | | | | (_| |
//    \_____|\___/  /_/      \_____|\___/|_|\__,_|_| |_|\__, |
//                                                       __/ |
//                                                      |___/
// *********************************************************************************************************************

type Test struct {
	name string
}

func (t *Test) Close() {
	fmt.Println(t.name, " closed")
}

func (t Test) Close2() {
	tools.Success("%v Closed2", t.name)
}

/**
 * 一个反例
 * @see		使用defer去Close一些资源时，需要注意
 * @param
 */
func CounterExample() {
	ts := []Test{{"a"}, {"b"}, {"c"}}
	for _, t := range ts {
		defer t.Close()
	}
	// 输出
	//c  closed
	//c  closed
	//c  closed

	//期望，原因参考 T_0() 的 defer底层原理 第4点
	//c closed
	//b closed
	//a closed

	// 为了验证第4点，这里使用了另外一个方法，通过传值的方式来处理，输出就正确了
	for _, t := range ts {
		defer t.Close2()
	}
	//2023/03/18 00:43:53 [SUCC]  c Closed2
	//2023/03/18 00:43:53 [SUCC]  b Closed2
	//2023/03/18 00:43:53 [SUCC]  a Closed2
}

func Close(t Test) {
	t.Close()
}

/**
 * 第一个解决办法
 * @see
 * @param
 */
func FirstToSolveCE() {
	fmt.Println()
	tools.Warning("第一个解决办法")
	ts := []Test{{"a"}, {"b"}, {"c"}}
	for _, t := range ts {
		defer Close(t)
	}
}

/**
 * 第二个解决办法
 * @see
 * @param
 */
func SecondToSolveCE() {
	fmt.Println()
	tools.Warning("第二个解决办法")
	ts := []Test{{"a"}, {"b"}, {"c"}}
	for _, t := range ts {
		t2 := t
		defer t2.Close()
	}
}

func ThirdToSolveCE() {
	fmt.Println()
	tools.Warning("第三个解决办法")
	ts := []Test{{"a"}, {"b"}, {"c"}}
	for _, t := range ts {
		defer func(t Test) {
			t.Close()
		}(t)
	}
}

// *********************************************************************************************************************
//     _____             __   _____       _
//    / ____|           / /  / ____|     | |
//   | |  __  ___      / /  | |  __  ___ | | __ _ _ __   __ _
//   | | |_ |/ _ \    / /   | | |_ |/ _ \| |/ _` | '_ \ / _` |
//   | |__| | (_) |  / /    | |__| | (_) | | (_| | | | | (_| |
//    \_____|\___/  /_/      \_____|\___/|_|\__,_|_| |_|\__, |
//                                                       __/ |
//                                                      |___/
// *********************************************************************************************************************

func test(x int) {
	defer println("a")
	defer println("b")

	defer func() {
		println(100 / x) // div0异常未被捕获，逐步往外传递，最终终止进程（如果是测试，则测试不通过）
	}()

	defer println("c")
}

/**
 * defer中发生了错误时
 * @see		多个 defer 注册，按 FILO 次序执行 ( 先进后出 )。哪怕函数或某个延迟调用发生错误，这些调用依旧会被执行
 * @param
 */
func DeferError() {
	test(0)
}

// *********************************************************************************************************************
//     _____             __   _____       _
//    / ____|           / /  / ____|     | |
//   | |  __  ___      / /  | |  __  ___ | | __ _ _ __   __ _
//   | | |_ |/ _ \    / /   | | |_ |/ _ \| |/ _` | '_ \ / _` |
//   | |__| | (_) |  / /    | |__| | (_) | | (_| | | | | (_| |
//    \_____|\___/  /_/      \_____|\___/|_|\__,_|_| |_|\__, |
//                                                       __/ |
//                                                      |___/
// *********************************************************************************************************************

/**
 * Defer的性能问题
 * @see		滥用 defer 可能会导致性能问题，尤其是在一个 "大循环" 里。
 * @param
 */

var lock sync.Mutex

func testBasic() {
	lock.Lock()
	lock.Unlock()
}

func testDefer() {
	lock.Lock()
	defer lock.Unlock()
}

/**
 * 性能处理，百万次的操作，能看出来一些差距
 * @see
 * @param
 */
func DeferPerformance() {
	func() {
		t1 := time.Now()

		for i := 0; i < 1000000; i++ {
			testBasic()
		}
		elapsed := time.Since(t1)
		fmt.Println("基础操作(不使用Defer处理Unlock)，花费: ", elapsed)
	}()

	func() {
		t1 := time.Now()

		for i := 0; i < 1000000; i++ {
			testDefer()
		}
		elapsed := time.Since(t1)
		fmt.Println("高级操作(不使用Defer处理Unlock)，花费: ", elapsed)
	}()
}
