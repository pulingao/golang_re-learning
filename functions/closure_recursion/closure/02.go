package closure

import (
	"fmt"
	"github.com/pulingao/golang_re-learning/tools"
	"time"
)

/**
 * 本篇示例参考：https://zhuanlan.zhihu.com/p/351428978
 * @see
 * @param
 */
func T_000() {
	s := `
************************************************************************************************************************
参考：https://zhuanlan.zhihu.com/p/56557423
	讲的还是不错的

defer的底层原理
	1.每次defer语句执行的时候，会把函数“压栈”，函数参数会被拷贝下来；
		当外层函数（非代码块，如一个for循环）退出时，defer函数按照定义的逆序执行；
		如果defer执行的函数为nil, 那么会在最终调用函数的产生panic.
	
	2.defer语句并不会马上执行，而是会进入一个栈，函数return前，会按先进后出的顺序执行。
		也就是说最先被定义的defer语句最后执行。
		先进后出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面先执行，那后面函数的依赖就没有了。
	
	3.在defer函数定义时，对外部变量的引用是有两种方式的，分别是作为函数参数和作为闭包引用。
		作为函数参数，则在defer定义时就把值传递给defer，并被cache起来；
		作为闭包引用的话，则会在defer函数真正调用时根据整个上下文确定当前的值。
	
	4.defer后面的语句在执行的时候，函数调用的参数会被保存起来，也就是复制了一份。
		真正执行的时候，实际上用到的是这个复制的变量，因此如果此变量是一个“值”，那么就和定义的时候是一致的。
		如果此变量是一个“引用”，那么就可能和定义的时候不一致。
************************************************************************************************************************
`
	fmt.Printf("%v\n", s)
}

func T_001() {
	i := 0

	// 结合T_000()的第三点，再来结合这里看

	// 当defer定义为一个闭包时: i是引用传递，则会再真正调用（执行）时，按照上下文来确定i的值，因此是100
	// 如果将i的更改放到defer的函数定义之前且后面没有再修改，则引用和值传递时，结果是一样的，参考：T_002()
	defer func() {
		fmt.Println("defer closure i:", i)
	}()

	// 非闭包: i是值传递，就是当时defer的函数定义时传入的值，因此是1
	defer fmt.Println("defer i:", i)

	// 修改i的值
	i = 100

	return
}

func T_002() {
	i := 0

	// 修改i的值
	i = 100

	// 结合T_000()的第三点，再来结合这里看

	// 当defer定义为一个闭包时: i是引用传递，则会再真正调用（执行）时，按照上下文来确定i的值，但是修改值的操作在defer定义之前，且后面没有在修改值
	defer func() {
		fmt.Println("defer closure i:", i) // 也是100
	}()

	// 非闭包: i是值传递，就是当时defer的函数定义时传入的值，但是修改值的操作在defer定义之前，且后面没有在修改值，因此是100
	defer fmt.Println("defer i:", i)

	return
}

// *********************************************************************************************************************
//     _____             __   _____       _
//    / ____|           / /  / ____|     | |
//   | |  __  ___      / /  | |  __  ___ | | __ _ _ __   __ _
//   | | |_ |/ _ \    / /   | | |_ |/ _ \| |/ _` | '_ \ / _` |
//   | |__| | (_) |  / /    | |__| | (_) | | (_| | | | | (_| |
//    \_____|\___/  /_/      \_____|\___/|_|\__,_|_| |_|\__, |
//                                                       __/ |
//                                                      |___/
// *********************************************************************************************************************

/*
返回匿名函数的函数
1) x是自由变量
2) 匿名函数和x自由变量共同组成闭包
*/
func Adder(x int) func(int) int {
	return func(y int) int {
		x += y
		fmt.Printf("x addr %p, x value %d\n", &x, x)
		return x
	}
}

func T_003() {
	// 类似于01.go中的T_03()方法
	fmt.Println("----------------Adder()返回的匿名函数实例1----------------")
	closure := Adder(1)
	closure(100)
	closure(1000)
	closure(10000)

	fmt.Println("----------------Adder()返回的匿名函数实例2----------------")
	closure2 := Adder(10)
	closure2(1)
	closure2(1)
	closure2(1)
	closure2(1)

	tools.NewLineWithCDL()

	tools.Warning("另外一个示例，说明了匿名函数下的值传递和引用传递，当时已经可以理解，写到这里做个记录")

	fmt.Println("----------------值传递----------------")
	for i := 0; i < 10; i++ {
		go func(x int) {
			fmt.Println(x)
		}(i)
	}
	time.Sleep(10 * time.Millisecond)

	fmt.Println("----------------引用传递----------------")
	for i := 0; i < 10; i++ {
		go func() {
			// 这里停顿1毫秒，能够更好的看出效果，否则就会因为for执行的过程，导致这里输出一些别的数字
			// 即使输出一些别的数字，这里也正确
			time.Sleep(time.Millisecond)
			fmt.Println(i)
		}()
	}

	// 等待goroutine输出全部结果后再结束
	time.Sleep(800 * time.Millisecond)

	return
}
