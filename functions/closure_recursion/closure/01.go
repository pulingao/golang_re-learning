package closure

import (
	"fmt"
	"github.com/pulingao/golang_re-learning/tools"
)

/**
 * 概念说明
 * @see
 * @param
 */
func T_00() {
	s := `
************************************************************************************************************************
匿名函数
	顾名思义就是没有名字的函数。很多语言都有如：java，js,php等，其中js最钟情。匿名函数最大的用途是来模拟块级作用域,避免数据污染的。

闭包
	说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕。
	另一种说法：
		由函数及其相关引用环境组成的实体，可以理解为一个函数“捕获”了和它处于同一作用域的其他变量

参考：
	1.https://segmentfault.com/a/1190000018689134
	2.https://zhuanlan.zhihu.com/p/351428978
	3.https://www.topgoer.com/%E5%87%BD%E6%95%B0/%E9%97%AD%E5%8C%85%E9%80%92%E5%BD%92.html
************************************************************************************************************************
`
	fmt.Printf("%v\n", s)
}

// *********************************************************************************************************************
//     _____             __   _____       _
//    / ____|           / /  / ____|     | |
//   | |  __  ___      / /  | |  __  ___ | | __ _ _ __   __ _
//   | | |_ |/ _ \    / /   | | |_ |/ _ \| |/ _` | '_ \ / _` |
//   | |__| | (_) |  / /    | |__| | (_) | | (_| | | | | (_| |
//    \_____|\___/  /_/      \_____|\___/|_|\__,_|_| |_|\__, |
//                                                       __/ |
//                                                      |___/
// *********************************************************************************************************************

func a() func() int {
	i := 0
	b := func() int {
		i++
		fmt.Println(i)
		return i
	}
	return b
}

func T_01() {
	c := a()
	c()
	c()
	c()

	a() //不会输出i
	fmt.Printf("a()类型: %T，这样 a()() 就会输出：%v\n", a(), a()())

}

// *********************************************************************************************************************
//     _____             __   _____       _
//    / ____|           / /  / ____|     | |
//   | |  __  ___      / /  | |  __  ___ | | __ _ _ __   __ _
//   | | |_ |/ _ \    / /   | | |_ |/ _ \| |/ _` | '_ \ / _` |
//   | |__| | (_) |  / /    | |__| | (_) | | (_| | | | | (_| |
//    \_____|\___/  /_/      \_____|\___/|_|\__,_|_| |_|\__, |
//                                                       __/ |
//                                                      |___/
// *********************************************************************************************************************

func test() func() {
	x := 100
	fmt.Printf("test中的：x (%p) = %d\n", &x, x)

	return func() {
		defer func() {
			fmt.Printf("defer中的：x (%p) = %d\n", &x, x)
		}()

		fmt.Printf("返回的匿名函数中的：x (%p) = %d\n", &x, x)
	}
}

func T_02() {
	f := test()
	f()
}

// 一个defer引用闭包的示例，等到defer时再来处理
func T_defer() {
	i := 0

	// 非闭包: i是值传递
	defer fmt.Println("defer i:", i, &i)

	// 闭包: i是引用传递
	defer func() {
		fmt.Println("defer closure i:", i, &i)
	}()

	// 修改i的值
	i = 100

	return
}

// *********************************************************************************************************************
//     _____             __   _____       _
//    / ____|           / /  / ____|     | |
//   | |  __  ___      / /  | |  __  ___ | | __ _ _ __   __ _
//   | | |_ |/ _ \    / /   | | |_ |/ _ \| |/ _` | '_ \ / _` |
//   | |__| | (_) |  / /    | |__| | (_) | | (_| | | | | (_| |
//    \_____|\___/  /_/      \_____|\___/|_|\__,_|_| |_|\__, |
//                                                       __/ |
//                                                      |___/
// *********************************************************************************************************************

// 外部引用函数参数局部变量
func add(base int) func(int) int {
	tools.Info("初始化base=%v", base)
	return func(i int) int {
		tools.Info("进入base=%v，i=%v", base, i)
		// base在这里相当于了函数的局部变量，函数没有结束，局部变量的值会一直保存
		base += i
		return base
	}
}

func T_03() {
	tmp1 := add(10)
	fmt.Println(tmp1(1), tmp1(2))

	// 此时tmp1和tmp2不是一个实体了
	tmp2 := add(100)
	fmt.Println(tmp2(1), tmp2(2))
}

// *********************************************************************************************************************
//     _____             __   _____       _
//    / ____|           / /  / ____|     | |
//   | |  __  ___      / /  | |  __  ___ | | __ _ _ __   __ _
//   | | |_ |/ _ \    / /   | | |_ |/ _ \| |/ _` | '_ \ / _` |
//   | |__| | (_) |  / /    | |__| | (_) | | (_| | | | | (_| |
//    \_____|\___/  /_/      \_____|\___/|_|\__,_|_| |_|\__, |
//                                                       __/ |
//                                                      |___/
// *********************************************************************************************************************

// 返回2个函数类型的返回值
type CalcFunc func(int) int

func test01(base int) (CalcFunc, CalcFunc) {
	// 定义2个函数，并返回
	// 相加
	add := func(i int) int {
		//base += i
		return base + i //如果是这样返回，则base的值就是初始值保持不变
	}
	// 相减
	sub := func(i int) int {
		//base -= i
		return base - i
	}

	// 返回
	return add, sub
}

func T_04() {
	f1, f2 := test01(10)

	// base一直是没有消失
	fmt.Println(f1(1), f2(2))

	// 此时base是9
	fmt.Println(f1(3), f2(4))
}
